=========================== Suppression complÃ¨te de Docker =================================================

# ArrÃªter tous les conteneurs en cours
docker stop $(docker ps -q) 2>/dev/null || true

# Supprimer tous les conteneurs
docker rm $(docker ps -aq) 2>/dev/null || true

# Supprimer toutes les images
docker rmi $(docker images -q) 2>/dev/null || true

# Nettoyer complÃ¨tement le systÃ¨me Docker
docker system prune -a --volumes --force 2>/dev/null || true

# ArrÃªter le service Docker
sudo systemctl stop docker
sudo systemctl stop docker.socket
sudo systemctl stop containerd

# DÃ©sinstaller les paquets Docker
sudo apt-get purge -y docker-engine docker docker.io docker-ce docker-ce-cli containerd.io docker-compose-plugin

# Supprimer les dÃ©pendances orphelines
sudo apt-get autoremove -y --purge docker-engine docker docker.io docker-ce docker-ce-cli containerd.io

# Supprimer le repository Docker
sudo rm /etc/apt/sources.list.d/docker.list 2>/dev/null || true
sudo rm /etc/apt/keyrings/docker.gpg 2>/dev/null || true

# Supprimer le dossier principal de Docker
sudo rm -rf /var/lib/docker
sudo rm -rf /var/lib/containerd

# Supprimer les fichiers de configuration
sudo rm -rf /etc/docker
sudo rm -rf ~/.docker

# Supprimer les fichiers de service systemd
sudo rm -f /etc/systemd/system/docker.service
sudo rm -f /etc/systemd/system/docker.socket
sudo rm -f /lib/systemd/system/docker.service
sudo rm -f /lib/systemd/system/docker.socket

# Recharger systemd
sudo systemctl daemon-reload

# Supprimer ton utilisateur du groupe docker
sudo deluser $USER docker 2>/dev/null || true

# Supprimer le groupe docker
sudo groupdel docker 2>/dev/null || true

# Supprimer les interfaces rÃ©seau Docker
sudo ip link delete docker0 2>/dev/null || true
sudo ip link delete br-* 2>/dev/null || true

# Nettoyer iptables des rÃ¨gles Docker
sudo iptables -t nat -F
sudo iptables -t nat -X
sudo iptables -t filter -F
sudo iptables -t filter -X

# VÃ©rifier qu'il ne reste plus rien
docker --version 2>/dev/null && echo "Docker encore prÃ©sent" || echo "Docker complÃ¨tement supprimÃ©"
sudo find / -name "*docker*" 2>/dev/null | grep -v proc | head -20

==================================== Script Complet de suppression de docker ===============================================



==================================== Installation de Docker ================================================================

# VÃ©rifier la version exacte de Debian
cat /etc/os-release

# VÃ©rifier l'architecture (doit Ãªtre x86_64)
uname -m

# VÃ©rifier l'espace disque
df -h

# Mettre Ã  jour le systÃ¨me
sudo apt update && sudo apt upgrade -y

# Installer les paquets nÃ©cessaires pour ajouter des repositories HTTPS
sudo apt install -y \
    apt-transport-https \
    ca-certificates \
    curl \
    gnupg \
    lsb-release

# CrÃ©er le dossier pour les clÃ©s
sudo mkdir -p /etc/apt/keyrings

# TÃ©lÃ©charger et ajouter la clÃ© GPG de Docker
curl -fsSL https://download.docker.com/linux/debian/gpg | sudo gpg --dearmor -o /etc/apt/keyrings/docker.gpg

# Donner les bonnes permissions Ã  la clÃ©
sudo chmod a+r /etc/apt/keyrings/docker.gpg

# Ajouter le repository officiel Docker pour Debian
echo \
  "deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/debian \
  $(lsb_release -cs) stable" | sudo tee /etc/apt/sources.list.d/docker.list > /dev/null

# Mettre Ã  jour la liste des paquets avec le nouveau repository
sudo apt update

# Installer Docker Engine, CLI et containerd
sudo apt install -y docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin

# DÃ©marrer et activer Docker au boot
sudo systemctl start docker
sudo systemctl enable docker

# VÃ©rifier que Docker tourne
sudo systemctl status docker

# Ajouter ton utilisateur au groupe docker
sudo usermod -aG docker $USER

# Appliquer le changement (ou redÃ©marre ta session)
newgrp docker

# VÃ©rifier la version
docker --version

# Nouvelle syntaxe (plugin intÃ©grÃ©)
docker compose version

# Au lieu de docker-compose up
docker compose up

# Au lieu de docker-compose down  
docker compose down

# Test avec le conteneur hello-world
docker run hello-world
----------------------------------------- Installation TerminÃ© -------------------------------------------------------------


Comprendre Docker et Docker Compose: Les bases

# Regardons ce qui s'est passÃ©
docker images
docker ps -a

# Lancer un serveur web
docker run -d -p 8080:80 --name mon-nginx nginx:latest

# Voir les conteneurs en cours
docker ps

# Tester le serveur web
curl http://localhost:8080
# Ou ouvre ton navigateur sur http://ton-ip-vm:8080

# Regarder les logs du conteneur
docker logs mon-nginx

# Voir les dÃ©tails du conteneur
docker inspect mon-nginx

# ExÃ©cuter une commande dans le conteneur
docker exec -it mon-nginx bash

# Tu es maintenant DANS le conteneur
ls /usr/share/nginx/html/  # Les fichiers web
ps aux                     # Les processus qui tournent
exit                       # Pour sortir

# CrÃ©er un fichier HTML sur ton systÃ¨me
echo "<h1>Salut ! Mon premier conteneur Docker</h1>" > index.html

# Copier ce fichier dans le conteneur
docker cp index.html mon-nginx:/usr/share/nginx/html/

# VÃ©rifier le changement
curl http://localhost:8080

# Mode interactif (premier plan)
docker run -it --name test-ubuntu ubuntu:22.04 bash

# Tu es maintenant dans un conteneur Ubuntu !
# Fais quelques commandes :
ls /
whoami
apt update && apt install -y curl
exit

# Le conteneur s'arrÃªte quand tu sors

# Lister tous les conteneurs (actifs et arrÃªtÃ©s)
docker ps -a

# RedÃ©marrer un conteneur arrÃªtÃ©
docker start test-ubuntu

# ArrÃªter un conteneur
docker stop mon-nginx

# Supprimer un conteneur (il doit Ãªtre arrÃªtÃ©)
docker rm test-ubuntu

# Forcer la suppression (mÃªme en cours)
docker rm -f mon-nginx
----------------------------------------------- Fin ----------------------------------------------------------------------

Exercice Pratique

# CrÃ©er un dossier pour notre projet
mkdir mon-premier-dockerfile
cd mon-premier-dockerfile

# VÃ©rifier qu'on est dans le bon dossier
pwd

# CrÃ©er les fichiers (utilise les artifacts ci-dessus)
# Dockerfile et welcome.sh dans le mÃªme dossier

# CrÃ©er le fichier welcome.sh
nano welcome.sh
# (ou vim welcome.sh si tu prÃ©fÃ¨res)

# CrÃ©er le Dockerfile (sans extension !)
nano Dockerfile

# VÃ©rifier qu'on a bien nos deux fichiers
ls -la

# Tu devrais voir :
# Dockerfile
# welcome.sh

# Construire ton image
docker build -t mon-image:v1 .

# Voir ta nouvelle image
docker images

# Lancer ton conteneur personnalisÃ©
docker run -d --name mon-conteneur mon-image:v1

# Te connecter Ã  ton conteneur
docker exec -it mon-conteneur bash

# Tu es maintenant dans TON conteneur personnalisÃ© !
# Tu peux voir ton script de bienvenue qui tourne
------------------------------------------------------ Pratique --------------------------------------------------
Test pratique:

# 1. CrÃ©er le dossier et aller dedans
mkdir mon-test-dockerfile && cd mon-test-dockerfile

# 2. CrÃ©er un Dockerfile simple
echo 'FROM ubuntu:22.04
RUN echo "Hello depuis MON image !" > /hello.txt
CMD cat /hello.txt' > Dockerfile

# 3. Construire l'image
docker build -t test-simple .

# 4. Lancer un conteneur
docker run test-simple
----------------------------------------------------- Fin ---------------------------------------------------------

# CrÃ©er un conteneur et y ajouter des donnÃ©es
docker run -it --name test-data ubuntu:22.04 bash
# Dans le conteneur :
echo "Mes donnÃ©es importantes" > /data.txt
exit

# Supprimer le conteneur
docker rm test-data

# ğŸ’¥ Tes donnÃ©es sont perdues !

# ========================================
# GUIDE PRATIQUE : VOLUMES DOCKER
# ========================================

# 1. VOLUMES DOCKER (RecommandÃ©)
# ==============================

# CrÃ©er un volume nommÃ©
docker volume create mon-volume

# Utiliser le volume
docker run -it --name app1 -v mon-volume:/app/data ubuntu:22.04 bash
# Dans le conteneur : echo "test" > /app/data/fichier.txt

# Le volume persiste mÃªme aprÃ¨s suppression du conteneur !
docker rm -f app1

# CrÃ©er un nouveau conteneur avec le mÃªme volume
docker run -it --name app2 -v mon-volume:/app/data ubuntu:22.04 bash
# Dans le conteneur : cat /app/data/fichier.txt â†’ "test" est toujours lÃ  !

# Lister les volumes
docker volume ls

# Voir les dÃ©tails d'un volume
docker volume inspect mon-volume

# 2. BIND MOUNTS (Dossiers de l'hÃ´te)
# ==================================

# CrÃ©er un dossier sur ton systÃ¨me
mkdir /home/$USER/mes-donnees
echo "Fichier depuis l'hÃ´te" > /home/$USER/mes-donnees/host-file.txt

# Monter ce dossier dans le conteneur
docker run -it --name bind-test -v /home/$USER/mes-donnees:/app/data ubuntu:22.04 bash
# Dans le conteneur : ls /app/data â†’ tu vois host-file.txt
# CrÃ©er un fichier : echo "Depuis le conteneur" > /app/data/container-file.txt

# Sur ton hÃ´te, vÃ©rifier :
ls /home/$USER/mes-donnees â†’ tu vois container-file.txt !

# 3. VOLUMES TEMPORAIRES (tmpfs)
# ==============================

# Stockage en RAM (perdu Ã  l'arrÃªt)
docker run -it --name temp-storage --tmpfs /tmp-data ubuntu:22.04 bash
# Dans le conteneur : echo "En mÃ©moire seulement" > /tmp-data/temp.txt

# 4. COMPARAISON DES MÃ‰THODES
# ===========================

echo "
VOLUMES DOCKER vs BIND MOUNTS vs TMPFS

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                 â”‚ Volume      â”‚ Bind Mount  â”‚ tmpfs       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Gestion         â”‚ Docker      â”‚ OS HÃ´te     â”‚ MÃ©moire     â”‚
â”‚ Performance     â”‚ Optimale    â”‚ DÃ©pend OS   â”‚ TrÃ¨s rapide â”‚
â”‚ Partage         â”‚ Facile      â”‚ Facile      â”‚ Non         â”‚
â”‚ Persistance     â”‚ Oui         â”‚ Oui         â”‚ Non         â”‚
â”‚ PortabilitÃ©     â”‚ Excellente  â”‚ LimitÃ©e     â”‚ Excellente  â”‚
â”‚ SÃ©curitÃ©        â”‚ IsolÃ©       â”‚ AccÃ¨s host  â”‚ IsolÃ©       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
"

# Lister les rÃ©seaux par dÃ©faut
docker network ls

# CrÃ©er un rÃ©seau personnalisÃ©
docker network create mon-reseau

# CrÃ©er deux conteneurs sur le mÃªme rÃ©seau
docker run -d --name web --network mon-reseau nginx:latest
docker run -it --name client --network mon-reseau ubuntu:22.04 bash

# Dans le conteneur client :
apt update && apt install -y curl
curl http://web  # âœ… Fonctionne ! Communication par nom

--------------------------------------------- Fin -----------------------------------------------------------------

# CrÃ©ation d'une application complÃ¨te avec base de donnÃ©es

version: '3.8'

services:
  # Base de donnÃ©es PostgreSQL
  database:
    image: postgres:15
    container_name: ma-db
    environment:
      POSTGRES_DB: monapp
      POSTGRES_USER: admin  
      POSTGRES_PASSWORD: secret123
    volumes:
      - db_data:/var/lib/postgresql/data
      - ./init.sql:/docker-entrypoint-initdb.d/init.sql:ro
    networks:
      - app_network
    restart: unless-stopped
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U admin -d monapp"]
      interval: 30s
      timeout: 10s
      retries: 3

  # Application web (Node.js)
  webapp:
    build: 
      context: ./app
      dockerfile: Dockerfile
    container_name: mon-app
    ports:
      - "3000:3000"
    environment:
      - NODE_ENV=development
      - DB_HOST=database
      - DB_USER=admin
      - DB_PASS=secret123
      - DB_NAME=monapp
    volumes:
      - ./app:/usr/src/app
      - /usr/src/app/node_modules  # Volume anonyme pour node_modules
    networks:
      - app_network
    depends_on:
      database:
        condition: service_healthy
    restart: unless-stopped

  # Reverse proxy Nginx
  proxy:
    image: nginx:alpine
    container_name: mon-proxy
    ports:
      - "80:80"
      - "443:443"
    volumes:
      - ./nginx.conf:/etc/nginx/nginx.conf:ro
      - ./ssl:/etc/nginx/ssl:ro
    networks:
      - app_network
    depends_on:
      - webapp
    restart: unless-stopped

  # Redis pour le cache
  cache:
    image: redis:7-alpine
    container_name: mon-cache
    command: redis-server --appendonly yes
    volumes:
      - cache_data:/data
    networks:
      - app_network
    restart: unless-stopped

  # Outil de monitoring (optionnel)
  adminer:
    image: adminer:latest
    container_name: db-admin
    ports:
      - "8080:8080"
    networks:
      - app_network
    depends_on:
      - database
    restart: unless-stopped

networks:
  app_network:
    driver: bridge
    ipam:
      config:
        - subnet: 172.20.0.0/16

volumes:
  db_data:
    driver: local
  cache_data:
    driver: local

# CrÃ©er la structure
mkdir lamp-docker && cd lamp-docker
mkdir www mysql-init

# CrÃ©er le docker-compose.yml (utilise l'artifact ci-dessus)

# CrÃ©er une page PHP de test
echo '<?php
echo "<h1>ğŸ³ Ma Stack LAMP Docker</h1>";
echo "<p>PHP Version: " . phpversion() . "</p>";

// Test connexion MySQL
try {
    $pdo = new PDO("mysql:host=database;dbname=lamp_db", "lamp_user", "lamp_pass");
    echo "<p style=\"color: green;\">âœ… Connexion MySQL OK</p>";
    
    // CrÃ©er une table de test
    $pdo->exec("CREATE TABLE IF NOT EXISTS test (id INT AUTO_INCREMENT PRIMARY KEY, message TEXT)");
    $pdo->exec("INSERT INTO test (message) VALUES (\"Hello from Docker!\")");
    
    $result = $pdo->query("SELECT * FROM test");
    echo "<h3>DonnÃ©es test :</h3><ul>";
    foreach($result as $row) {
        echo "<li>" . $row["message"] . "</li>";
    }
    echo "</ul>";
    
} catch(PDOException $e) {
    echo "<p style=\"color: red;\">âŒ Erreur MySQL: " . $e->getMessage() . "</p>";
}

echo "<hr><a href=\"http://localhost:8080\" target=\"_blank\">ğŸ“Š AccÃ©der Ã  phpMyAdmin</a>";
?>' > www/index.php

# Lancer la stack
docker compose up -d

# VÃ©rifier que tout tourne
docker compose ps

----------------------------------------- Fin --------------------------------------------------------------------


# Surveillance et monitoring

# Voir les ressources utilisÃ©es par tes conteneurs
docker stats

# Logs en temps rÃ©el d'un service spÃ©cifique
docker compose logs -f web

# Inspecter un conteneur en dÃ©tail
docker inspect lamp_web

# Voir les processus dans un conteneur
docker top lamp_web

================= DEBUGGING COURANT =======================
# Entrer dans un conteneur pour investiguer
docker exec -it lamp_web bash

# Si le conteneur crash, voir les logs
docker compose logs database

# Tester la connectivitÃ© rÃ©seau
docker exec -it lamp_web ping database

================ Variables d'environnement ================
# ========================================
# GESTION DES VARIABLES D'ENVIRONNEMENT
# ========================================

# 1. CrÃ©er un fichier .env (ne jamais commiter en prod !)
cat > .env << 'EOF'
# Configuration de la base de donnÃ©es
DB_NAME=lamp_db
DB_USER=lamp_user
DB_PASS=lamp_secret_password
DB_ROOT_PASS=super_secret_root

# Configuration de l'application
APP_ENV=development
APP_PORT=3000
APP_SECRET=mon-secret-key-tres-long

# Configuration Redis
REDIS_PORT=6379
EOF

# 2. Modifier docker-compose.yml pour utiliser les variables
cat > docker-compose.yml << 'EOF'
services:
  database:
    image: mysql:8.0
    container_name: lamp_db
    environment:
      MYSQL_ROOT_PASSWORD: ${DB_ROOT_PASS}
      MYSQL_DATABASE: ${DB_NAME}
      MYSQL_USER: ${DB_USER}
      MYSQL_PASSWORD: ${DB_PASS}
    volumes:
      - db_data:/var/lib/mysql
    networks:
      - lamp_network
    restart: unless-stopped

  web:
    image: php:8.2-apache
    container_name: lamp_web
    ports:
      - "${APP_PORT:-3000}:80"
    environment:
      - APP_ENV=${APP_ENV}
      - DB_HOST=database
      - DB_NAME=${DB_NAME}
      - DB_USER=${DB_USER}
      - DB_PASS=${DB_PASS}
    volumes:
      - ./www:/var/www/html
    networks:
      - lamp_network
    depends_on:
      - database
    restart: unless-stopped

  cache:
    image: redis:7-alpine
    container_name: lamp_cache
    ports:
      - "${REDIS_PORT}:6379"
    networks:
      - lamp_network
    restart: unless-stopped

networks:
  lamp_network:
    driver: bridge

volumes:
  db_data:
EOF

# 3. Test avec les variables
docker compose config  # Voir la config finale avec les variables remplacÃ©es
docker compose up -d

------------------------------------ Multi-environnement Configs --------------------------------------------------

# =========================================
# STRUCTURE MULTI-ENVIRONNEMENTS
# =========================================

# docker-compose.yml (base commune)
services:
  app:
    build: .
    networks:
      - app_network
    
  database:
    image: postgres:15
    networks:
      - app_network

networks:
  app_network:

# docker-compose.override.yml (dÃ©veloppement par dÃ©faut)
# Se charge automatiquement avec docker-compose.yml
services:
  app:
    ports:
      - "3000:3000"
    volumes:
      - .:/app          # Code en live reload
      - /app/node_modules
    environment:
      - NODE_ENV=development
      - DEBUG=true
    command: npm run dev
    
  database:
    ports:
      - "5432:5432"     # AccÃ¨s direct Ã  la DB en dev
    environment:
      POSTGRES_DB: devdb
      POSTGRES_PASSWORD: devpass
    volumes:
      - ./dev-data:/var/lib/postgresql/data

# docker-compose.prod.yml (production)
services:
  app:
    ports:
      - "80:3000"
    environment:
      - NODE_ENV=production
      - DEBUG=false
    restart: unless-stopped
    deploy:
      resources:
        limits:
          memory: 512M
          cpus: '0.5'
    
  database:
    environment:
      POSTGRES_DB: proddb
      POSTGRES_PASSWORD_FILE: /run/secrets/db_password
    volumes:
      - prod_db_data:/var/lib/postgresql/data
    secrets:
      - db_password
    restart: unless-stopped

# docker-compose.test.yml (tests)
services:
  app:
    environment:
      - NODE_ENV=test
      - DB_NAME=testdb
    command: npm test
    
  database:
    environment:
      POSTGRES_DB: testdb
      POSTGRES_PASSWORD: testpass
    tmpfs:
      - /var/lib/postgresql/data  # DB en mÃ©moire pour les tests

secrets:
  db_password:
    file: ./secrets/db_password.txt

volumes:
  prod_db_data:

# =========================================
# COMMANDES POUR CHAQUE ENVIRONNEMENT
# =========================================

# DÃ©veloppement (par dÃ©faut)
# docker compose up -d

# Production
# docker compose -f docker-compose.yml -f docker-compose.prod.yml up -d

# Tests
# docker compose -f docker-compose.yml -f docker-compose.test.yml up --abort-on-container-exit

--------------------------------------- Debugging d'erreur --------------------------------------------------------
# 1. Nettoyer ce qui ne marche pas
docker compose down -v

# 2. Supprimer le mauvais fichier
rm docker-compose.yml

# 3. CrÃ©er la bonne configuration LAMP
cat > docker-compose.yml << 'EOF'
services:
  web:
    image: php:8.2-apache
    container_name: lamp_web
    ports:
      - "80:80"
    volumes:
      - ./www:/var/www/html
    networks:
      - lamp_network
    depends_on:
      - database
    restart: unless-stopped

  database:
    image: mysql:8.0
    container_name: lamp_db
    environment:
      MYSQL_ROOT_PASSWORD: rootpassword
      MYSQL_DATABASE: lamp_db
      MYSQL_USER: lamp_user
      MYSQL_PASSWORD: lamp_pass
    volumes:
      - db_data:/var/lib/mysql
    networks:
      - lamp_network
    restart: unless-stopped

  phpmyadmin:
    image: phpmyadmin:latest
    container_name: lamp_pma
    ports:
      - "8080:80"
    environment:
      PMA_HOST: database
      PMA_USER: root
      PMA_PASSWORD: rootpassword
    networks:
      - lamp_network
    depends_on:
      - database
    restart: unless-stopped

networks:
  lamp_network:
    driver: bridge

volumes:
  db_data:
EOF

# 4. VÃ©rifier que le dossier www existe et a le fichier PHP
ls -la www/

# S'il n'existe pas, crÃ©er le fichier de test :
echo '<?php
phpinfo();
?>' > www/index.php

# 5. Tester la configuration avant de lancer
docker compose config

# 6. Lancer la stack
docker compose up -d

# 7. VÃ©rifier
docker compose ps